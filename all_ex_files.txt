
================================================================================
FILE: lib/lab4/application.ex
================================================================================

defmodule Lab4.Application do
  @moduledoc false
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      {Registry, keys: :unique, name: Lab4.PeerRegistry},
      {DynamicSupervisor, strategy: :one_for_one, name: Lab4.RuntimeSupervisor},
      {Lab4.Router, []}
    ]

    opts = [strategy: :one_for_one, name: Lab4.Supervisor]
    Supervisor.start_link(children, opts)
  end
end


================================================================================
FILE: lib/lab4/cli.ex
================================================================================

defmodule Lab4.CLI do
  @moduledoc false

  def main(argv) do
    {:ok, _} = Application.ensure_all_started(:lab4)

    case argv do
      ["serve" | rest] ->
        serve(rest)

      ["connect" | rest] ->
        connect(rest)

      _ ->
        usage()
    end
  end

  defp serve(args) do
    {opts, _, _} =
      OptionParser.parse(args,
        switches: [username: :string, port: :integer, key: :string],
        aliases: [u: :username, p: :port, k: :key]
      )

    username = opts[:username] || "user"
    port = opts[:port] || 5555
    psk = opts[:key] || Lab4.PSK.generate_base64url_32()

    :ok = Lab4.Router.configure_identity(username, psk)
    {:ok, _} = Lab4.Router.listen(port)

    IO.puts("Serving as #{username} on port #{port}")
    IO.puts("PSK: #{psk}")

    start_repl(username)
  end

  defp connect(args) do
    {opts, _, _} =
      OptionParser.parse(args,
        switches: [username: :string, host: :string, port: :integer, key: :string],
        aliases: [u: :username, h: :host, p: :port, k: :key]
      )

    username = opts[:username] || "user"
    host = opts[:host] || "127.0.0.1"
    port = opts[:port] || 5555
    psk = opts[:key] || ""

    :ok = Lab4.Router.configure_identity(username, psk)

    case Lab4.Router.connect(host, port) do
      {:ok, _pid} ->
        IO.puts("Connected to #{host}:#{port} as #{username}")
        start_repl(username)

      {:error, reason} ->
        IO.puts("Connect error: #{inspect(reason)}")
        System.halt(2)
    end
  end

  defp start_repl(username) do
    {:ok, repl} = Lab4.CLI.Repl.start_link(username: username)
    :ok = Lab4.Router.attach_ui(repl)

    input_loop(repl)
  end

  defp input_loop(repl_pid) do
    case IO.gets("") do
      :eof ->
        send(repl_pid, {:line, "/quit"})

      {:error, _} ->
        send(repl_pid, {:line, "/quit"})

      line ->
        send(repl_pid, {:line, String.trim(line)})
        input_loop(repl_pid)
    end
  end

  defp usage do
    IO.puts("""
    lab4 serve   --username NAME [--port 5555] [--key PSK]
    lab4 connect --username NAME --host HOST [--port 5555] --key PSK
    """)
  end
end


================================================================================
FILE: lib/lab4/psk.ex
================================================================================

defmodule Lab4.PSK do
  @spec generate_base64url_32() :: String.t()
  def generate_base64url_32 do
    32
    |> :crypto.strong_rand_bytes()
    |> Base.url_encode64(padding: false)
  end
end


================================================================================
FILE: lib/lab4/router.ex
================================================================================

defmodule Lab4.Router do
  @moduledoc false
  use GenServer

  @type state :: %{
          username: String.t() | nil,
          psk: String.t() | nil,
          listener: pid() | nil,
          ui_pid: pid() | nil,
          sessions: MapSet.t(pid())
        }

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  ## Public API

  def attach_ui(pid) when is_pid(pid), do: GenServer.call(__MODULE__, {:attach_ui, pid})

  def configure_identity(username, psk) do
    GenServer.call(__MODULE__, {:configure_identity, username, psk})
  end

  def change_nick(new_username) do
    GenServer.call(__MODULE__, {:change_nick, new_username})
  end

  def listen(port) when is_integer(port) do
    GenServer.call(__MODULE__, {:listen, port})
  end

  def connect(host, port) when is_binary(host) and is_integer(port) do
    GenServer.call(__MODULE__, {:connect, host, port})
  end

  def peers do
    Registry.select(Lab4.PeerRegistry, [{{:"$1", :"$2", :_}, [], [{{:"$1", :"$2"}}]}])
  end

  def send_msg(peer_username, text) do
    GenServer.call(__MODULE__, {:send_msg, peer_username, text})
  end

  def identity do
    GenServer.call(__MODULE__, :identity)
  end

  ## Called by sessions

  def register_session(pid) do
    GenServer.cast(__MODULE__, {:register_session, pid})
  end

  def unregister_session(pid) do
    GenServer.cast(__MODULE__, {:unregister_session, pid})
  end

  def register_peer(peer_username, session_pid) do
    Registry.register(Lab4.PeerRegistry, peer_username, session_pid)
    notify_ui({:peer_up, peer_username})
    :ok
  end

  def unregister_peer(peer_username) do
    Registry.unregister(Lab4.PeerRegistry, peer_username)
    notify_ui({:peer_down, peer_username})
    :ok
  end

  def incoming_message(from, body) do
    notify_ui({:incoming, from, body})
    :ok
  end

  defp notify_ui(msg) do
    case GenServer.whereis(__MODULE__) do
      nil -> :ok
      pid -> GenServer.cast(pid, {:notify_ui, msg})
    end
  end

  ## GenServer

  @impl true
  def init(_args) do
    {:ok, %{username: nil, psk: nil, listener: nil, ui_pid: nil, sessions: MapSet.new()}}
  end

  @impl true
  def handle_call({:attach_ui, pid}, _from, st) do
    {:reply, :ok, %{st | ui_pid: pid}}
  end

  @impl true
  def handle_call({:configure_identity, username, psk}, _from, st) do
    {:reply, :ok, %{st | username: username, psk: psk}}
  end

  @impl true
  def handle_call(:identity, _from, st) do
    {:reply, {st.username, st.psk}, st}
  end

  @impl true
  def handle_call({:change_nick, new_username}, _from, st) do
    Enum.each(st.sessions, fn pid ->
      GenServer.cast(pid, {:set_username, new_username})
    end)

    {:reply, :ok, %{st | username: new_username}}
  end

  @impl true
  def handle_call({:listen, port}, _from, st) do
    if st.username == nil or st.psk == nil do
      {:reply, {:error, :identity_not_set}, st}
    else
      spec = {Lab4.Net.Listener, [port: port, username: st.username, psk: st.psk]}

      case DynamicSupervisor.start_child(Lab4.RuntimeSupervisor, spec) do
        {:ok, pid} ->
          {:reply, {:ok, pid}, %{st | listener: pid}}

        {:error, {:already_started, pid}} ->
          {:reply, {:ok, pid}, %{st | listener: pid}}

        {:error, reason} ->
          {:reply, {:error, reason}, st}
      end
    end
  end

  @impl true
  def handle_call({:connect, host, port}, _from, st) do
    if st.username == nil or st.psk == nil do
      {:reply, {:error, :identity_not_set}, st}
    else
      spec =
        {Lab4.Net.Session,
         [
           role: :client,
           host: host,
           port: port,
           username: st.username,
           psk: st.psk
         ]}

      case DynamicSupervisor.start_child(Lab4.RuntimeSupervisor, spec) do
        {:ok, pid} -> {:reply, {:ok, pid}, st}
        {:error, reason} -> {:reply, {:error, reason}, st}
      end
    end
  end


@impl true
def handle_call({:send_msg, peer_username, text}, _from, st) do
  case Registry.lookup(Lab4.PeerRegistry, peer_username) do
    [{_owner_pid, session_pid} | _] ->
      res = GenServer.call(session_pid, {:send_chat, peer_username, text})
      {:reply, res, st}

    [] ->
      {:reply, {:error, :unknown_peer}, st}
  end
end



  @impl true
  def handle_cast({:register_session, pid}, st) do
    {:noreply, %{st | sessions: MapSet.put(st.sessions, pid)}}
  end

  @impl true
  def handle_cast({:unregister_session, pid}, st) do
    {:noreply, %{st | sessions: MapSet.delete(st.sessions, pid)}}
  end

  @impl true
  def handle_cast({:notify_ui, msg}, st) do
    if is_pid(st.ui_pid) do
      send(st.ui_pid, msg)
    end

    {:noreply, st}
  end
end


================================================================================
FILE: lib/lab4/xml.ex
================================================================================

defmodule Lab4.Xml do
  @moduledoc false

  @doc """
  Minimal XML helper used by the app. Returns/accepts binaries.

  This intentionally avoids any NIFs and uses simple regex-based parsing
  because the protocol is tiny and well-known.
  """

  @spec parse(binary()) :: {:ok, binary()} | {:error, any()}
  def parse(bin) when is_binary(bin), do: {:ok, bin}
  def parse(_), do: {:error, :not_binary}

  @spec to_binary(binary()) :: binary()
  def to_binary(bin) when is_binary(bin), do: bin

  ## Elements - return binary strings
  def stream_start(username) when is_binary(username) do
    "<stream user=\"#{escape(username)}\" version=\"1.0\"/>"
  end

  def handshake(username, key) when is_binary(username) and is_binary(key) do
    "<handshake user=\"#{escape(username)}\" key=\"#{escape(key)}\"/>"
  end

  def ok(username) when is_binary(username) do
    "<ok user=\"#{escape(username)}\"/>"
  end

  def error(reason) when is_binary(reason) do
    "<error reason=\"#{escape(reason)}\"/>"
  end

  def message(from, to, body)
      when is_binary(from) and is_binary(to) and is_binary(body) do
    "<message from=\"#{escape(from)}\" to=\"#{escape(to)}\" type=\"chat\"><body>#{escape_cdata(body)}</body></message>"
  end

  def ping, do: "<ping/>"
  def pong, do: "<pong/>"

  ## Classification - analyze raw binary and return same tuples as original code
  def classify(bin) when is_binary(bin) do
    cond do
      Regex.match?(~r/^<stream(\s|>)/, bin) ->
        {:stream, get_attr(bin, "user")}

      Regex.match?(~r/^<handshake(\s|>)/, bin) ->
        {:handshake, get_attr(bin, "user"), get_attr(bin, "key")}

      Regex.match?(~r/^<ok(\s|>)/, bin) ->
        {:ok, get_attr(bin, "user")}

      Regex.match?(~r/^<error(\s|>)/, bin) ->
        {:error, get_attr(bin, "reason")}

      Regex.match?(~r/^<message(\s|>)/, bin) ->
        from = get_attr(bin, "from")
        to = get_attr(bin, "to")
        body = get_body(bin)
        {:message, from, to, body}

      Regex.match?(~r/^<ping(\s|>)/, bin) ->
        {:ping}

      Regex.match?(~r/^<pong(\s|>)/, bin) ->
        {:pong}

      true ->
        {:unknown, bin}
    end
  end

  ## Helpers

  defp get_attr(bin, key) do
    # простая регулярка для attr="value"
    case Regex.run(~r/#{key}="([^"]*)"/, bin) do
      [_, v] -> v
      _ -> nil
    end
  end

  defp get_body(bin) do
    # захватываем содержимое между <body>...</body>, s-флаг для многострочности
    case Regex.run(~r|<body>(.*?)</body>|s, bin) do
      [_, content] -> unescape_cdata(content)
      _ -> ""
    end
  end

  defp escape(s) when is_binary(s) do
    s
    |> String.replace("&", "&amp;")
    |> String.replace("\"", "&quot;")
    |> String.replace("<", "&lt;")
    |> String.replace(">", "&gt;")
  end

  # для текста внутри body мы тоже экранируем минимально
  defp escape_cdata(s) when is_binary(s), do: escape(s)

  defp unescape_cdata(s) when is_binary(s) do
    s
    |> String.replace("&quot;", "\"")
    |> String.replace("&amp;", "&")
    |> String.replace("&lt;", "<")
    |> String.replace("&gt;", ">")
  end
end


================================================================================
FILE: lib/lab4/cli/repl.ex
================================================================================

defmodule Lab4.CLI.Repl do
  @moduledoc false
  use GenServer

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    username = Keyword.fetch!(opts, :username)
    st = %{username: username, history: [], last_peer: nil, active_peer: nil}

    repl_pid = self()
    gl = Process.group_leader()

    # Отдельная задача, которая читает stdin и шлет строки в GenServer
    Task.start_link(fn ->
      # Важно: IO идет через group leader процесса
      Process.group_leader(self(), gl)

      IO.stream(:stdio, :line)
      |> Enum.each(fn line ->
        send(repl_pid, {:line, String.trim(line)})
      end)

      # EOF/закрытие stdin
      send(repl_pid, {:line, "/quit"})
    end)

    IO.puts(help_text())
    prompt(username)
    {:ok, st}
  end

  @impl true
  def handle_info({:line, ""}, st) do
    prompt(st.username)
    {:noreply, st}
  end

  @impl true
  def handle_info({:line, line}, st) do
    {line, st} = maybe_expand_history(line, st)
    st = push_history(line, st)

    st =
      case parse_command(line) do
        {:help} ->
          IO.puts(help_text())
          st

        {:history} ->
          print_history(st.history)
          st

        {:peers} ->
          peers = Lab4.Router.peers()
          print_peers(peers)
          st

        {:msg, peer, text} ->
          send_to_peer(peer, text)
          %{st | last_peer: peer, active_peer: st.active_peer || peer}

        {:send_default, text} ->
          case resolve_default_peer(st) do
            {:ok, peer} ->
              send_to_peer(peer, text)
              %{st | last_peer: peer, active_peer: st.active_peer || peer}

            {:error, reason} ->
              IO.puts(reason)
              st
          end

        {:nick, new_username} ->
          :ok = Lab4.Router.change_nick(new_username)
          IO.puts("Nick changed to #{new_username}")
          %{st | username: new_username}

        {:use, peer} ->
          IO.puts("Active peer: #{peer}")
          %{st | active_peer: peer}

        {:quit} ->
          IO.puts("Bye.")
          System.halt(0)

        {:unknown, _} ->
          IO.puts("Unknown command. Type /help")
          st
      end

    prompt(st.username)
    {:noreply, st}
  end

  ## Messages from Router

  @impl true
  def handle_info({:incoming, from, body}, st) do
    IO.puts("\n#{from}: #{body}")

    st = %{st | last_peer: from, active_peer: st.active_peer || from}

    prompt(st.username)
    {:noreply, st}
  end

  @impl true
  def handle_info({:peer_up, peer}, st) do
    IO.puts("\n[peer up] #{peer}")
    prompt(st.username)
    {:noreply, st}
  end

  @impl true
  def handle_info({:peer_down, peer}, st) do
    IO.puts("\n[peer down] #{peer}")
    prompt(st.username)
    {:noreply, st}
  end

  ## Helpers

  defp parse_command("/help"), do: {:help}
  defp parse_command("/history"), do: {:history}
  defp parse_command("/peers"), do: {:peers}
  defp parse_command("/quit"), do: {:quit}

  defp parse_command(line) do
    cond do
      String.starts_with?(line, "/msg ") ->
        rest = String.trim_leading(line, "/msg ")

        case String.split(rest, " ", parts: 2) do
          [peer, text] -> {:msg, peer, text}
          _ -> {:unknown, line}
        end

      String.starts_with?(line, "/nick ") ->
        new = String.trim_leading(line, "/nick ") |> String.trim()

        if new == "" do
          {:unknown, line}
        else
          {:nick, new}
        end

      String.starts_with?(line, "/use ") ->
        peer = String.trim_leading(line, "/use ") |> String.trim()

        if peer == "" do
          {:unknown, line}
        else
          {:use, peer}
        end

      String.starts_with?(line, "/") ->
        {:unknown, line}

      true ->
        {:send_default, line}
    end
  end

  defp send_to_peer(peer, text) do
    case Lab4.Router.send_msg(peer, text) do
      :ok -> :ok
      {:error, reason} -> IO.puts("Send error: #{inspect(reason)}")
    end
  end

  defp resolve_default_peer(st) do
    cond do
      st.active_peer != nil ->
        {:ok, st.active_peer}

      st.last_peer != nil ->
        {:ok, st.last_peer}

      true ->
        peers = Lab4.Router.peers()

        case peers do
          [{peer, _pid}] ->
            {:ok, peer}

          [] ->
            {:error, "No peers connected. Use /peers."}

          _many ->
            {:error, "Multiple peers. Use /use <peer> or /msg <peer> <text>."}
        end
    end
  end

  defp push_history(line, st) do
    history =
      case st.history do
        [^line | _] -> st.history
        _ -> [line | st.history]
      end

    %{st | history: Enum.take(history, 50)}
  end

  defp maybe_expand_history("!" <> n, st) do
    case Integer.parse(n) do
      {idx, ""} ->
        list = Enum.reverse(st.history)

        if idx >= 1 and idx <= length(list) do
          expanded = Enum.at(list, idx - 1)
          IO.puts(expanded)
          {expanded, st}
        else
          {"", st}
        end

      _ ->
        {"", st}
    end
  end

  defp maybe_expand_history(line, st), do: {line, st}

  defp print_history(history) do
    list = Enum.reverse(history)

    list
    |> Enum.with_index(1)
    |> Enum.each(fn {cmd, i} -> IO.puts("#{i}: #{cmd}") end)

    IO.puts("Use !N to repeat.")
  end

  defp print_peers(peers) do
    if peers == [] do
      IO.puts("(no peers)")
    else
      Enum.each(peers, fn {peer, _pid} -> IO.puts(peer) end)
    end
  end

  defp prompt(username) do
    IO.write("#{username}> ")
  end

  defp help_text do
    """
    Commands:
      /help
      /peers
      /msg <peer_username> <text>
      /nick <new_username>
      /use <peer_username>   (set active peer)
      /history
      !<n>   (repeat command)
      /quit

    Plain text without leading '/' is sent to the active peer.
    """
  end
end


================================================================================
FILE: lib/lab4/net/frame.ex
================================================================================

defmodule Lab4.Net.Frame do
  @moduledoc """
  Very small binary framing:
  [uint32_be length][payload bytes...]

  This avoids ambiguity when reading XML from raw TCP streams.
  """

  @spec encode(binary()) :: binary()
  def encode(payload) when is_binary(payload) do
    <<byte_size(payload)::unsigned-big-32, payload::binary>>
  end

  @spec decode(binary()) :: {[binary()], binary()}
  def decode(buffer) when is_binary(buffer) do
    do_decode(buffer, [])
  end

  defp do_decode(<<len::unsigned-big-32, rest::binary>>, acc) when byte_size(rest) >= len do
    <<payload::binary-size(len), tail::binary>> = rest
    do_decode(tail, [payload | acc])
  end

  defp do_decode(buffer, acc) do
    {Enum.reverse(acc), buffer}
  end
end


================================================================================
FILE: lib/lab4/net/listener.ex
================================================================================

defmodule Lab4.Net.Listener do
  @moduledoc false
  use GenServer
  require Logger

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts)
  end

  @impl true
  def init(opts) do
    port = Keyword.fetch!(opts, :port)
    username = Keyword.fetch!(opts, :username)
    psk = Keyword.fetch!(opts, :psk)

    tcp_opts = [
      :binary,
      active: false,
      packet: :raw,
      reuseaddr: true,
      nodelay: true,
      backlog: 128
    ]

    case :gen_tcp.listen(port, tcp_opts) do
      {:ok, lsock} ->
        Logger.info("Listening on 0.0.0.0:#{port}")
        state = %{lsock: lsock, username: username, psk: psk}
        send(self(), :accept)
        {:ok, state}

      {:error, reason} ->
        {:stop, reason}
    end
  end

  @impl true
  def handle_info(:accept, st) do
    case :gen_tcp.accept(st.lsock) do
      {:ok, sock} ->
        spec =
          {Lab4.Net.Session,
           [
             role: :server,
             socket: sock,
             username: st.username,
             psk: st.psk
           ]}

        case DynamicSupervisor.start_child(Lab4.RuntimeSupervisor, spec) do
          {:ok, sess_pid} ->
            :ok = :gen_tcp.controlling_process(sock, sess_pid)

          {:error, reason} ->
            Logger.error("Failed to start session: #{inspect(reason)}")
            :gen_tcp.close(sock)
        end

        send(self(), :accept)
        {:noreply, st}

      {:error, reason} ->
        {:stop, reason, st}
    end
  end
end


================================================================================
FILE: lib/lab4/net/session.ex
================================================================================

defmodule Lab4.Net.Session do
  @moduledoc false
  use GenServer
  require Logger

  alias Lab4.Net.Frame
  alias Lab4.Xml

  @ping_interval 30_000

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts)
  end

  @impl true
  def init(opts) do
    role = Keyword.fetch!(opts, :role)
    username = Keyword.fetch!(opts, :username)
    psk = Keyword.fetch!(opts, :psk)

    now = System.monotonic_time(:millisecond)

    case role do
      :client ->
        host = Keyword.fetch!(opts, :host)
        port = Keyword.fetch!(opts, :port)

        tcp_opts = [:binary, active: false, packet: :raw, nodelay: true]

        with {:ok, sock} <- :gen_tcp.connect(String.to_charlist(host), port, tcp_opts, 5_000) do
          :ok = :inet.setopts(sock, active: :once)
          st = base_state(role, sock, username, psk, now)
          Lab4.Router.register_session(self())
          send(self(), :send_stream)
          send(self(), :send_handshake)
          Process.send_after(self(), :tick, @ping_interval)
          {:ok, st}
        else
          {:error, reason} -> {:stop, reason}
        end

      :server ->
        sock = Keyword.fetch!(opts, :socket)
        :ok = :inet.setopts(sock, active: :once)
        st = base_state(role, sock, username, psk, now)
        Lab4.Router.register_session(self())
        Process.send_after(self(), :tick, @ping_interval)
        {:ok, st}
    end
  end

  defp base_state(role, sock, username, psk, now) do
    %{
      role: role,
      sock: sock,
      username: username,
      psk: psk,
      authed?: false,
      peer_username: nil,
      buffer: <<>>,
      last_rx: now
    }
  end

  ## GenServer callbacks

  @impl true
  def handle_info(:send_stream, st) do
    frame =
      st.username
      |> Xml.stream_start()
      |> Xml.to_binary()

    :ok = :gen_tcp.send(st.sock, Frame.encode(frame))
    {:noreply, st}
  end

  @impl true
  def handle_info(:send_handshake, st) do
    hs = Xml.handshake(st.username, st.psk) |> Xml.to_binary()
    :ok = :gen_tcp.send(st.sock, Frame.encode(hs))
    {:noreply, st}
  end

  @impl true
  def handle_info({:tcp, _sock, data}, st) do
    st = %{st | buffer: st.buffer <> data}
    {frames, rest} = Frame.decode(st.buffer)
    st = %{st | buffer: rest}

    st =
      Enum.reduce(frames, st, fn frame, acc ->
        handle_frame(frame, acc)
      end)

    :ok = :inet.setopts(st.sock, active: :once)
    {:noreply, st}
  end

  @impl true
  def handle_info({:tcp_closed, _sock}, st) do
    if st.peer_username, do: Lab4.Router.unregister_peer(st.peer_username)
    Lab4.Router.unregister_session(self())
    {:stop, :normal, st}
  end

  @impl true
  def handle_info({:tcp_error, _sock, reason}, st) do
    if st.peer_username, do: Lab4.Router.unregister_peer(st.peer_username)
    Lab4.Router.unregister_session(self())
    {:stop, reason, st}
  end

  @impl true
  def handle_info(:tick, st) do
    now = System.monotonic_time(:millisecond)

    st =
      if st.authed? and now - st.last_rx >= @ping_interval do
        ping = Xml.ping() |> Xml.to_binary()
        :ok = :gen_tcp.send(st.sock, Frame.encode(ping))
        st
      else
        st
      end

    Process.send_after(self(), :tick, @ping_interval)
    {:noreply, st}
  end

  @impl true
  def handle_call({:send_chat, to_peer, text}, _from, st) do
    if st.authed? do
      from = st.username
      msg = Xml.message(from, to_peer, text) |> Xml.to_binary()
      res = :gen_tcp.send(st.sock, Frame.encode(msg))
      {:reply, res, st}
    else
      {:reply, {:error, :not_authenticated}, st}
    end
  end

  @impl true
  def handle_cast({:set_username, new_username}, st) do
    {:noreply, %{st | username: new_username}}
  end

  ## Internal

  defp handle_frame(frame, st) do
    case Xml.parse(frame) do
      {:ok, doc} ->
        case Xml.classify(doc) do
          {:stream, peer_user} ->
            Logger.debug("Stream header from #{inspect(peer_user)}")
            touch(st)

          {:handshake, peer_user, key} ->
            st = touch(st)
            handle_handshake(peer_user, key, st)

          {:ok, peer_user} ->
            st = touch(st)
            handle_ok(peer_user, st)

          {:error, reason} ->
            Logger.warning("Peer error: #{inspect(reason)}")
            touch(st)

          {:message, from, _to, body} ->
            Lab4.Router.incoming_message(from, body)
            touch(st)

          {:ping} ->
            pong = Xml.pong() |> Xml.to_binary()
            :ok = :gen_tcp.send(st.sock, Frame.encode(pong))
            touch(st)

          {:pong} ->
            touch(st)

          {:unknown, _} ->
            st
        end

      {:error, reason} ->
        Logger.warning("Bad XML frame: #{inspect(reason)}")
        st
    end
  end

  defp handle_handshake(peer_user, key, st) do
    cond do
      st.authed? ->
        st

      key != st.psk ->
        err = Xml.error("bad-key") |> Xml.to_binary()
        _ = :gen_tcp.send(st.sock, Frame.encode(err))
        _ = :gen_tcp.close(st.sock)
        st

      true ->
        ok = Xml.ok(st.username) |> Xml.to_binary()
        :ok = :gen_tcp.send(st.sock, Frame.encode(ok))
        Lab4.Router.register_peer(peer_user, self())
        %{st | authed?: true, peer_username: peer_user}
    end
  end

  defp handle_ok(peer_user, st) do
    if st.authed? do
      st
    else
      Lab4.Router.register_peer(peer_user, self())
      %{st | authed?: true, peer_username: peer_user}
    end
  end

  defp touch(st) do
    %{st | last_rx: System.monotonic_time(:millisecond)}
  end
end

